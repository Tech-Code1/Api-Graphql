"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Query = require("./Query");

var _Query2 = _interopRequireDefault(_Query);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QUERY = "query";
var EXEC = "exec";
var LOGIN = "login";
var ERROR = "error";
var COMMIT = "commit";
var DATA = "data";
var SUBSCRIBE = "subscribe";
var TOKEN = "token";

// value encoding types
var STRING_ENCODING = "string";

function log() {
	if ((typeof console === "undefined" ? "undefined" : _typeof(console)) == 'object' && console.log) {
		var _console;

		(_console = console).log.apply(_console, arguments);
	}
}

var OFFLINE = new Error('Offline');

var Connection = function () {
	function Connection(ws) {
		var _this = this;

		_classCallCheck(this, Connection);

		this.handleMessage = function (evt) {
			var msg = JSON.parse(evt.data);
			if (_this.promises[msg.tag]) {
				_this.handlePromiseMessage(msg);
			} else if (_this.subscriptions[msg.subscription]) {
				_this.handleSubscriptionMessage(msg);
			} else {
				throw new Error('unhandled msg: ' + evt.data);
			}
		};

		this.socket = function () {
			return Promise.resolve(ws);
		};
		ws.onmessage = this.handleMessage;
		ws.onclose = function () {
			_this.socket = function () {
				return Promise.reject(OFFLINE);
			};
			_this.onClose();
		};
		this.promises = {};
		this.subscriptions = {};
		this.n = 0;
	}

	_createClass(Connection, [{
		key: "close",
		value: function close() {
			return this.socket().then(function (ws) {
				ws.close();
			});
		}
	}, {
		key: "nextTag",
		value: function nextTag() {
			this.n++;
			return this.n.toString();
		}
	}, {
		key: "send",
		value: function send(msg) {
			var _this2 = this;

			return this.socket().then(function (ws) {
				return _this2._send(ws, msg);
			});
		}
	}, {
		key: "_send",
		value: function _send(ws, msg) {
			var _this3 = this;

			return new Promise(function (resolve, reject) {
				msg.tag = _this3.nextTag();
				_this3.promises[msg.tag] = resolve;
				ws.send(JSON.stringify(msg), function (err) {
					if (err) {
						reject(err);
					}
				});
			});
		}
	}, {
		key: "handlePromiseMessage",
		value: function handlePromiseMessage(msg) {
			var handler = this.promises[msg.tag];
			if (msg.type == ERROR) {
				handler(Promise.reject(new Error(msg.error)));
			} else {
				handler(msg);
			}
			delete this.promises[msg.tag];
		}
	}, {
		key: "handleSubscriptionMessage",
		value: function handleSubscriptionMessage(msg) {
			var query = this.subscriptions[msg.subscription];
			if (msg.type == ERROR) {
				query._onError(msg.error);
			} else if (msg.type == DATA) {
				query._onData(msg);
			} else {
				throw new Error('query subscription cannot handle msg type:' + msg.type);
			}
		}
	}, {
		key: "normalizeQuery",
		value: function normalizeQuery(query) {
			if (!/^\s*query\s/.test(query)) {
				query = "query { " + query + " }";
			}
			return query;
		}
	}, {
		key: "query",
		value: function query(_query, params) {
			return this.do(QUERY, this.normalizeQuery(_query), params);
		}
	}, {
		key: "subscribe",
		value: function subscribe(name, query, params) {
			var q = new _Query2.default(name, query, params);
			return this._subscribe(q);
		}
	}, {
		key: "_subscribe",
		value: function _subscribe(query) {
			var _this4 = this;

			if (!query.id) {
				return Promise.reject(new Error('subscribe: name is required'));
			}
			if (!query.query) {
				return Promise.reject(new Error('subscribe: query is required'));
			}
			return this.send({
				type: "subscribe",
				subscription: query.id,
				query: this.normalizeQuery(query.query),
				params: query.params || {}
			}).then(function (msg) {
				_this4.subscriptions[query.id] = query;
				return query;
			});
		}
	}, {
		key: "unsubscribe",
		value: function unsubscribe(id) {
			var _this5 = this;

			return this.send({
				type: "unsubscribe",
				subscription: id
			}).then(function (msg) {
				delete _this5.subscriptions[id];
				return msg;
			});
		}
	}, {
		key: "buildQuery",
		value: function buildQuery(kind, name, query, paramTypes, params) {
			var definition = name;
			if (params) {
				var types = [];
				for (var k in params) {
					var paramType = paramTypes[k];
					if (!paramType) {
						if (typeof params[k] == 'string') {
							paramType = 'String!';
						} else if (typeof params[k] == 'boolean') {
							paramType = 'Boolean!';
						} else {
							throw new Error('invalid param: no paramType given');
						}
					}
					types.push("$" + k + ": " + paramType);
				}
				definition = name + "(" + types.join(',') + ")";
			}
			return kind + " " + definition + " { " + query + " }";
		}
	}, {
		key: "mutation",
		value: function mutation(args) {
			var q = this.buildQuery("mutation", "M", args.query, args.input, args.params);
			return this.do(EXEC, q, args.params);
		}
	}, {
		key: "do",
		value: function _do(kind, query, args) {
			return this.send({
				type: kind,
				query: query,
				params: args || {}
			}).then(function (msg) {
				if (!msg.data) {
					return Promise.reject(new Error('no result data'));
				}
				if (msg.data.errors && msg.data.errors.length > 0) {
					return Promise.reject(new Error(msg.data.errors.map(function (err) {
						return err.message;
					}).join(' AND ')));
				}
				return msg.data.data;
			});
		}
	}, {
		key: "toPlaceholders",
		value: function toPlaceholders(args) {
			var placeholders = [];
			for (var k in args) {
				placeholders.push(k + ": $" + k);
			}
			return placeholders.join(', ');
		}
	}, {
		key: "markDirty",
		value: function markDirty() {
			this.dirty = true;
			this.onDirty();
		}
	}, {
		key: "markClean",
		value: function markClean() {
			this.dirty = false;
			this.onClean();
		}
	}, {
		key: "onDirty",
		value: function onDirty() {
			// set by user
		}
	}, {
		key: "onClean",
		value: function onClean() {
			// set by user
		}
	}, {
		key: "onClose",
		value: function onClose() {
			// set by user
		}
	}, {
		key: "setType",
		value: function setType(args, returning) {
			var _this6 = this;

			if (!returning) {
				returning = "id";
			}
			return this.mutation({
				input: {
					name: 'String!',
					fields: '[FieldArg]'
				},
				query: "\n\t\t\t\ttype:setType(" + this.toPlaceholders(args) + ") {\n\t\t\t\t\t" + returning + "\n\t\t\t\t}\n\t\t\t",
				params: args
			}).then(function (data) {
				_this6.markDirty();
				return data.type;
			});
		}

		// example setNode({id:"0001", type:"Page", values:{name:"my page"}})

	}, {
		key: "setNode",
		value: function setNode(args, returning) {
			var _this7 = this;

			var node = args;
			return this.mutation({
				input: {
					id: 'String!',
					type: 'String!',
					attrs: '[AttrArg]'
				},
				query: "\n\t\t\t\tnode:setNode(" + this.toPlaceholders(node) + ") {\n\t\t\t\t\t" + (returning || 'id') + "\n\t\t\t\t}\n\t\t\t",
				params: node
			}).then(function (data) {
				_this7.markDirty();
				return data.node;
			});
		}
	}, {
		key: "removeNodes",
		value: function removeNodes(args, returning) {
			var _this8 = this;

			if (!returning) {
				returning = "id";
			}
			return this.mutation({
				input: {
					id: 'String!'
				},
				query: "\n\t\t\t\tnode:removeNodes(" + this.toPlaceholders(args) + ") {\n\t\t\t\t\t" + returning + "\n\t\t\t\t}\n\t\t\t",
				params: args
			}).then(function (data) {
				_this8.markDirty();
				return data.node;
			});
		}
	}, {
		key: "setEdge",
		value: function setEdge(args, returning) {
			var _this9 = this;

			if (!returning) {
				returning = "\n\t\t\t\tfrom {id}\n\t\t\t\tto {id}\n\t\t\t\tname\n\t\t\t";
			}
			return this.mutation({
				input: {
					to: 'String!',
					from: 'String!',
					name: 'String!'
				},
				query: "\n\t\t\t\tedge:setEdge(" + this.toPlaceholders(args) + ") {\n\t\t\t\t\t" + returning + "\n\t\t\t\t}\n\t\t\t",
				params: args
			}).then(function (data) {
				_this9.markDirty();
				return data.edge;
			});
		}
	}, {
		key: "removeEdges",
		value: function removeEdges(args, returning) {
			var _this10 = this;

			if (!returning) {
				returning = "\n\t\t\t\tfrom {id}\n\t\t\t\tto {id}\n\t\t\t\tname\n\t\t\t";
			}
			return this.mutation({
				input: {
					to: 'String!',
					from: 'String!',
					name: 'String!'
				},
				query: "\n\t\t\t\tedges:removeEdges(" + this.toPlaceholders(args) + ") {\n\t\t\t\t\t" + returning + "\n\t\t\t\t}\n\t\t\t",
				params: args
			}).then(function (data) {
				_this10.markDirty();
				return data.edges;
			});
		}
	}, {
		key: "commit",
		value: function commit() {
			var _this11 = this;

			return this.send({
				type: COMMIT
			}).then(function (msg) {
				if (msg.type != 'ok') {
					return Promise.reject(new Error('expected ok got:' + JSON.stringify(msg)));
				}
				_this11.markClean();
			});
		}
	}]);

	return Connection;
}();

exports.default = Connection;