'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Connection = require('./Connection');

var _Connection2 = _interopRequireDefault(_Connection);

require('whatwg-fetch');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var REQUEST_HEADERS = {
	'Accept': 'application/json',
	'Content-Type': 'application/json'
};

var Client = function () {
	function Client(cfg) {
		_classCallCheck(this, Client);

		this.host = cfg.host || 'toolbox.oxdi.eu:8282';
	}

	_createClass(Client, [{
		key: 'register',
		value: function register(o) {
			var _this = this;

			// returns Promise<UserToken>
			return this._post('/register', o).then(function () {
				return _this.authenticate({
					id: o.id,
					password: o.password
				});
			});
		}
	}, {
		key: 'authenticate',
		value: function authenticate(o) {
			// returns Promise<UserToken>
			return this._post('/authenticate', o);
		}
	}, {
		key: 'createApp',
		value: function createApp(o) {
			return this._post('/apps', o);
		}
	}, {
		key: 'getUser',
		value: function getUser(_ref) {
			var userToken = _ref.userToken;

			return this._get('/user', { userToken: userToken });
		}
	}, {
		key: 'connect',
		value: function connect(_ref2) {
			var _this2 = this;

			var userID = _ref2.userID;
			var password = _ref2.password;
			var appID = _ref2.appID;
			var sessionToken = _ref2.sessionToken;
			var userToken = _ref2.userToken;

			if (sessionToken) {
				return this.connectSession({ sessionToken: sessionToken });
			}
			return (userToken ? Promise.resolve(userToken) : this.authenticate({ id: userID, password: password })).then(function (_ref3) {
				var userToken = _ref3.userToken;

				return _this2.createSession({
					appID: appID,
					userToken: userToken
				});
			}).then(function (_ref4) {
				var sessionToken = _ref4.sessionToken;

				return _this2.connectSession({ sessionToken: sessionToken });
			});
		}
	}, {
		key: 'connectSession',
		value: function connectSession(_ref5) {
			var sessionToken = _ref5.sessionToken;
			// returns Promise<Connection>
			if (!sessionToken) {
				return Promise.reject(new Error('sessionToken is required'));
			}
			if (typeof sessionToken != 'string') {
				return Promise.reject(new Error('sessionToken is required to be a string'));
			}
			var url = this._abs('/connect?sessionToken=' + sessionToken);
			return new Promise(function (resolve, reject) {
				var ws = void 0;
				try {
					ws = new WebSocket('ws:' + url);
				} catch (e) {
					reject(e);
					return;
				}
				ws.onmessage = function (evt) {
					var msg = JSON.parse(evt.data);
					if (msg.type == 'fatal') {
						reject(new Error(msg.error));
					} else if (msg.type == 'ok') {
						var conn = new _Connection2.default(ws);
						resolve(conn);
					}
				};
				ws.onerror = function () {
					reject(new Error('connection failed'));
				};
			});
		}
	}, {
		key: 'createSession',
		value: function createSession(o) {
			// returns Promise<Session>
			return this._post('/sessions', o);
		}
	}, {
		key: '_abs',
		value: function _abs(path) {
			return '//' + this.host + path;
		}
	}, {
		key: '_responseTextError',
		value: function _responseTextError(res) {
			return res.text().then(function (err) {
				return Promise.reject(new Error(err));
			});
		}
	}, {
		key: '_fetch',
		value: function _fetch(method, path, data) {
			var _this3 = this;

			var opts = {
				method: method,
				headers: REQUEST_HEADERS
			};
			if (data) {
				if (data.userToken) {
					var userToken = data.userToken;
					delete data.userToken;
					opts.headers = Object.assign(opts.headers, {
						Authorization: 'Bearer ' + userToken
					});
				}
				if (method != 'GET') {
					opts.body = JSON.stringify(data);
				}
			}
			return fetch(this._abs(path), opts).then(function (res) {
				if (res.status >= 200 && res.status < 300) {
					return res.json();
				} else {
					return _this3._responseTextError(res);
				}
			});
		}
	}, {
		key: '_post',
		value: function _post(path, data) {
			return this._fetch('POST', path, data);
		}
	}, {
		key: '_get',
		value: function _get(path, data) {
			return this._fetch('GET', path, data);
		}
	}]);

	return Client;
}();

exports.default = Client;